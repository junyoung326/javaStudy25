desc emp; -- emp 테이블 구조보기
select * from emp; -- emp 테이블 내용보기

desc dept; -- dept 테이블 구조보기
select * from dept; -- dept 테이블 내용보기

desc bonus; -- bonus 테이블 구조보기
select * from bonus; -- bonus 테이블 내용보기

desc salgrade; -- salgrade 테이블 구조보기
select * from salgrade; -- salgrade 테이블 내용보기

select empno, ename, deptno from emp; -- 열을 쉼표로 구분하여 출력하기

select distinct deptno from emp; -- distinct로 열의 중복 제거하기

select distinct job, deptno from emp; -- 여러 개 열을 명시하여 중복 제거하기

select all job, deptno from emp; -- 직책, 부서 번호 출력하기(ALL 사용)

select ename, sal, sal*12+comm, comm from emp; -- 열에 연산식을 사용하여 출력하기

select ename, sal, sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+comm, comm from emp; -- 곱하기를 사용하지 않고 연간 총 수입 출력하기

select ename, sal*12+comm as annsal, comm from emp; -- 별칭을 사용하여 사원의 연간 총 수입 출력하기

select * from emp order by sal; -- emp 테이블의 모든 열을 급여 기준으로 오름차순 정렬하기
select * from emp order by sal desc; -- emp 테이블의 모든 열을 급여 기준으로 내림차순 정렬하기
select * from emp order by empno desc; -- emp 테이블의 모든 열을 사원 번호 기준으로 내림차순 정렬하기
select * from emp order by deptno asc, sal desc; -- emp 테이블의 전체 열을 부서 번호 (오름차순) 급여(내림차순)로 정렬하기

SELECT DISTINCT JOB FROM EMP; -- 92P Q2

SELECT EMPNO AS EMPLOYEE_NO, ENAME AS EMPLOYEE_NAME, MGR AS SALARY, COMM AS COMMISSION, DEPTNO AS DEPARTMENT_NO
FROM EMP ORDER BY DEPTNO DESC, ENAME ASC; -- 92P Q3

select * from emp where deptno = 30; -- 부서 번호가 30인 데이터만 출력하기

select * from emp where deptno = 30 and job = 'SALESMAN'; -- and 연산자로 여러 개의 조건식 사용하기

select * from emp where deptno = 30 or job = 'CLERK'; -- or 연산자로 여러 개의 출력 조건 사용하기
select * from emp where deptno = 20 or job = 'SALESMAN'; -- or 연산자로 여러 개의 출력 조건 사용하기

select * from emp where sal * 12 = 36000; -- 곱셈 산술 연산자를 사용한 예

select * from emp where sal >= 3000; -- 대소 비교 연산자를 사용하여 출력하기

select * from emp where ename >= 'F'; -- 문자를 대소 비교 연산자로 비교하기(비교 문자열이 문자 하나일 때)

select * from emp where ename <= 'FORZ'; -- 문자열을 대소 비교 연산자로 비교하기 (비교 문자열이 여러 개일 때)

select * from emp where sal != 3000; -- 등가 비교 연산자(!=)를 사용하여 출력하기

select * from emp where sal <> 3000; -- 등가 비교 연산자(<>)를 사용하여 출력하기

select * from emp where sal ^= 3000; -- 등가 비교 연산자(^=)를 사용하여 출력하기

select * from emp where not sal = 3000; -- not 연산자를 사용하여 출력하기

select * from emp where job = 'MANAGER' or job = 'SALESMAN' or job = 'CLERK'; -- or 연산자를 사용하여 여러 개 조건을 만족하는 데이터 출력하기

SELECT * FROM EMP WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK'); -- IN 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE JOB != 'MANAGER' AND JOB <> 'SALESMAN' AND JOB ^= 'CLERK'; -- 등가 비교 연산자와 AND 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK'); -- IN 연산자와 논리 부정 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000; -- 대소 비교 연산자와 AND 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000; -- BETWEEN A AND B 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000; -- BETWEEN A AND B 연산자와 NOT 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE ENAME LIKE 'S%'; -- LIKE 연산자 사용하여 출력하기

SELECT * FROM EMP WHERE ENAME LIKE '_L%'; -- 사원 이름의 두 번째 글자가 L인 사원만 출력하기

SELECT * FROM EMP WHERE ENAME LIKE '%AM%'; -- 사원 이름에 AM이 포함되어 있는 사원 데이터만 출력하기

SELECT * FROM EMP WHERE ENAME NOT LIKE '%AM%'; -- 사원 이름에 AM이 포함되어 있지 않은 사원 데이터 출력하기

SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP; -- 별칭을 사용하여 열 이름 출력하기

SELECT * FROM EMP WHERE COMM = NULL; -- 등가 비교 연산자로 NULL 비교하기

SELECT * FROM EMP WHERE COMM IS NULL; -- IS NULL 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE MGR IS NOT NULL; -- 직속 상관이 있는 사원 데이터만 출력하기

SELECT * FROM EMP WHERE SAL > NULL AND COMM IS NULL; -- AND 연산자와 IS NULL 연산자 이용하기

SELECT * FROM EMP WHERE SAL > NULL OR COMM IS NULL; -- OR 연산자와 IS NULL 연산자 사용하기

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10 
UNION 
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20; -- 집합 연산자(UNION)를 사용하여 출력하기

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 20; -- 집합 연산자(UNION)를 사용하여 출력하기 (출력 열 개수가 다를 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT ENAME, EMPNO, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20; -- 집합 연산자(UNION)를 사용하여 출력하기 (출력 열의 자료형이 다를 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT SAL, JOB, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20; -- 집합 연산자(UNION)를 사용하여 출력하기 (출력 열 개수와 자료형이 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10; -- 집합 연산자(UNION)를 사용하여 출력하기 (출력 결과 데이터가 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10; -- 집합 연산자(UNION ALL)를 사용하여 출력하기 (출력 결과 데이터가 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10; -- 집합 연산자(MINUS)를 사용하여 출력하기

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10; -- 집합 연산자(INTERSECT)를 사용하여 출력하기

SELECT * FROM EMP WHERE ENAME LIKE '%S';  -- 125P Q1

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO = 30 AND JOB = 'SALESMAN'; -- 125P Q2

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20 AND SAL > 2000 OR DEPTNO = 30 AND SAL > 2000; -- 125P Q3 집합연산자를 사용하지 않은 방식

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20 AND SAL > 2000
UNION
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO = 30 AND SAL > 2000 -- 125P Q3 집합연산자를 사용한 방식

SELECT * FROM EMP WHERE SAL >= 2000 
UNION
SELECT * FROM EMP WHERE SAL <= 3000; -- 126P Q4

SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP WHERE DEPTNO =30 AND 
ENAME LIKE '%E%' AND SAL NOT BETWEEN 1000 AND 2000; -- 126P Q5

SELECT * FROM EMP WHERE JOB IN ('MANAGER','CLERK')
AND COMM IS NULL 
AND MGR IS NOT NULL
AND EMPNO NOT LIKE '_L%'; -- 126P Q6

-------------------- 조인 -----------------------

SELECT * FROM EMP, DEPT ORDER BY EMPNO; -- FROM절에 여러 테이블 선언하기

SELECT * FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO ORDER BY EMPNO; -- 열 이름을 비교하는 조건식으로 조인하기

SELECT * FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO ORDER BY EMPNO; -- 테이블 이름을 별칭으로 표현하기

SELECT E.EMPNO, E.NAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO ORDER BY EMPNO; -- -- 테이블 이름을 별칭으로 표현하기 (실무 꿀팁)

SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO; -- 두 테이블에 부서 번호가 똑같은 열 이름으로 포함되어 있을 때

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO ORDER BY D.DEPTNO, E.EMPNO;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND SAL >= 3000; -- WHERE절에 추가로 조건식 넣어 출력하기

SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL <=2500 AND E.EMPNO<=9999; -- 223P 1분 복습

SELECT * FROM EMP E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; -- 급여 범위를 지정하는 조건식으로 조인하기
 
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO; -- 같은 테이블을 두 번 사용하여 자체 조인하기

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO(+) ORDER BY E1.EMPNO; -- 왼쪽 외부 조인 사용하기

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1, EMP E2 WHERE E1.MGR(+) = E2.EMPNO ORDER BY E1.EMPNO; -- 오른쪽 외부 조인 사용하기

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO; -- NATURAL JOIN을 사용하여 조인하기

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC FROM EMP E JOIN DEPT D USING (DEPTNO) WHERE SAL >= 3000 ORDER BY DEPTNO, E.EMPNO; -- JOING ~ USING을 사용하여 조인하기
   
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO) WHERE SAL <= 3000 ORDER BY E.DEPTNO, EMPNO; -- JOIN ~ ON으로 등가 조인하기

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO; -- 왼쪽 외부 조인을 SQL-99로 작성하기

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO, MGR_EMPNO; -- 오른쪽 외부 조인을 SQL-99로 작성하기

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS EMR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO; -- 전체 외부 조인을 SQL-99로 작성하기

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.NAME, D.LOC FROM EMP E JOIN DEPT D USING (DEPTNO) WHERE SAL >= 3000 AND E.MGR IS NOT NULL ORDER BY DEPTNO, E.EMPNO; 
-- 238P 1분 복습 : EMP 테이블과 DEPT 테이블의 조인 조건은 부서번호(DEPTNO)가 같을 때이다. 급여는 3000 이상이며 직속상관이 반드시 있어야 한다.

-- 239P Q1
-- SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 2000;
-- SQL-99방식
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM EMP E NATURAL JOIN DEPT D WHERE E.SAL > 2000;

-- 239P Q2
--SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;
--SQL-99 방식
SELECT DEPTNO, D.DNAME, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT FROM EMP E JOIN DEPT D USING (DEPTNO) GROUP BY DEPTNO, D.DNAME;

-- 239P Q3
--SQL-99 이전 방식 
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO(+) = D.DEPTNO ORDER BY D.DEPTNO, E.ENAME;
--SQL-99 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO) ORDER BY D.DEPTNO, E.ENAME;

CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT; -- DEPT 테이블을 복사해서 DEPT_TEMP 테이블 만들기
SELECT * FROM DEPT_TEMP; -- DEPT_TEMP 테이블 전체 열 조회하기

CREATE TABLE EMP_TEMP10 AS SELECT * FROM EMP; -- EMP 테이블과 동등한 열 구조, 데이터를 가지는 EMP_TEMP10 테이블을 생성

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SEOUL');
SELECT * FROM DEPT_TEMP; -- DEPT_TEMP 테이블에 데이터 추가하기

INSERT INTO DEPT_TEMP VALUES(60, 'NETWORK', 'BUSAN');
SELECT * FROM DEPT_TEMP; -- INSERT문에 열 지정 없이 데이터 추가하기

INSERT INTO DEPT_TEMP (DEPTNO, LOC) VALUES (90, 'INCHEON');
SELECT * FROM DEPT_TEMP; -- 열 데이터를 넣지 않는 방식으로 NULL 데이터 입력하기

CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1; 
SELECT * FROM EMP_TEMP; -- EMP 테이블을 복사해서 EMP_TEMP 테이블 만들기

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (9999, '홍길동', 'PRESIDENT', NULL, '2001/01/01', 5000, 1000, 10);
SELECT * FROM EMP_TEMP; -- INSERT문으로 날짜 데이터 입력하기 (날짜 사이에 / 입력)

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES(1111, '성춘향', 'MANAGER', 9999, '2001-01-05', 4000, NULL, 20);
SELECT * FROM EMP_TEMP; -- INSERT문으로 날짜 데이터 입력하기 (날짜 사이에 - 입력)

-- INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (2111, '이순신', 'MANAGER', 9999, 07/01/2001' 4000, NULL, 20);
-- 10-11 날짜 데이터 형식을 반대로 했을 때

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (2111, '이순신', 'MANAGER', 9999, TO_DATE('07/01/2001', 'DD/MM/YYYY'), 4000, NULL, 20);
SELECT * FROM EMP_TEMP; -- TO_DATE 함수 사용하여 날짜 데이터 입력하기

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (3111, '심청이', 'MANAGER', 9999, SYSDATE, 4000, NULL, 30);
SELECT * FROM EMP_TEMP; -- 10-13 // SYSDATE를 사용하여 날짜 데이터 입력하기

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO FROM EMP E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 1;
SELECT * FROM EMP_TEMP;  -- 10-14 // 서브쿼리로 여러 데이터 추가하기

CREATE TABLE DEPT_TEMP2 AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP2; -- 10-15 // DEPT 테이블 복사해서 DEPT_TEMP2 테이블 만들기

UPDATE DEPT_TEMP2 SET LOC = 'SEOUL';
SELECT * FROM DEPT_TEMP2; -- 10-16 // DEPT_TEMP2 테이블 업데이트하기

ROLLBACK; -- 10-17// ROLLBACK으로 테이블 내용을 이전 상태로 되돌리기

UPDATE DEPT_TEMP2 SET DNAME = 'DATABASE', LOC = 'SEOUL' WHERE DEPTNO = 40;
SELECT * FROM DEPT_TEMP2; -- 10-18 테이블 데이터 중 일부분만 수정하기

UPDATE EMP_TEMP SET COMM = 50 WHERE SAL <= 2500; -- 279P 1분복습 

UPDATE DEPT_TEMP2 SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40) WHERE DEPTNO = 40;
SELECT * FROM DEPT_TEMP2; -- 10-19 // 서브쿼리로 데이터 일부분 수정하기

UPDATE DEPT_TEMP2 SET DNAME = (SELECT DNAME FROM DEPT WHERE DEPTNO = 40), LOC = (SELECT LOC FROM DEPT WHERE DEPTNO = 40) WHERE DEPTNO = 40; 
-- 10-20 // 서브쿼리로 데이터 일부분 수정하기

UPDATE DEPT_TEMP2 SET LOC = 'SEOUL' WHERE DEPTNO = (SELECT DEPTNO FROM DEPT_TEMP2 WHERE DNAME = 'OPERATIONS');
SELECT * FROM DEPT_TEMP2; -- 10-21 // UPDATE문의 WHERE절에 서브쿼리 사용하기

CREATE TABLE EMP_TEMP2 AS SELECT * FROM EMP;
SELECT * FROM EMP_TEMP2; -- EMP 테이블을 복사해서 EMP_TEMP2 테이블 만들기

DELETE FROM EMP_TEMP2 WHERE JOB = 'MANAGER';
SELECT * FROM EMP_TEMP2; -- 10-23// WHERE절을 사용하여 데이터 일부분만 삭제하기

DELETE FROM EMP_TEMP2 WHERE EMPNO IN (SELECT E.EMPNO FROM EMP_TEMP2 E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 3 AND DEPTNO = 30);
SELECT * FROM EMP_TEMP2; -- 10-24// WHERE절에 서브쿼리를 사용하여 데이터 일부만 삭제하기 

DELETE FROM EMP_TEMP2; 
SELECT * FROM EMP_TEMP2; -- 10-25// 테이블에 있는 전체 데이터 삭제하기

-- 1. A 계좌 잔액을 0원으로 변경하는 UPDATE문 실행
UPDATE ACCOUNT SET BALANCE = 0 WHERE ACCNO = A계좌번호;
-- 2. B 계좌 잔액을 100만원으로 변경하는 UPDATE문 실행 
UPDATE ACCOUNT SET BALANCE = 1000000 WHERE ACCNO = B계좌번호;

CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT; 
SELECT * FROM DEPT_TCL; -- 11-1// DEPT 테이블을 복사해서 DEPT_TCL 테이블 만들기

INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO =40;
DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';
SELECT * FROM DEPT_TCL; -- 11-2

CREATE TABLE EMP_DDL(EMPNO NUMBER(4), ENAME VARCHAR2(10), JOB VARCHAR2(9), MGR NUMBER(4), HIREDATE DATE, SAL NUMBER(7,2), COMM NUMBER(7,2), DEPTNO NUMBER(2));
DESC EMP_DDL; -- 12-1 모든 열의 각 자료형을 정의해서 테이블 생성하기

-- 12-2 다른 테이블을 복사하여 테이블 생성하기
CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;
DESC DEPT_DDL;

-- 12-3 DEPT_DDL 테이블 전체 조회하기
SELECT * FROM DEPT_DDL;

-- 12-4 다른 테이블의 일부를 복사하여 테이블 생성하기
CREATE TABLE EMP_DDL_30 AS SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP_DDL_30;

-- 12-5 다른 테이블을 복사하여 테이블 생성하기
CREATE TABLE EMPDEPT_DDL AS SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE 1 <> 1;
SELECT * FROM EMPDEPT_DDL;

-- 12-6 EMP 테이블을 복사하여 EMP_ALTER 테이블 생성하기
CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;
SELECT * FROM EMP_ALTER;

-- 12-7 ALTER 명령어로 HP 열 추가하기
ALTER TABLE EMP_ALTER ADD HP VARCHAR2(20);
SELECT * FROM EMP_ALTER;

-- 12-8 ALTER 명령어로 HP 열 이름을 TEL로 변경하기
ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;
SELECT * FROM EMP_ALTER;

-- 12-9 ALTER 명령어로 EMPNO 열 길이 변경하기
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
DESC EMP_ALTER;

-- 12-10 ALTER 명령어로 TEL열 삭제하기
ALTER TABLE EMP_ALTER DROP COLUMN TEL;
SELECT * FROM EMP_ALTER;

-- 12-11 테이블 이름 변경하기
RENAME EMP_ALTER TO EMP_RENAME;

-- 12-12 바꾸기 전 이름으로 테이블 구성 살펴보기
DESC EMP_ALTER;

-- 12-13 변경된 테이블 이름 (EMP_RENAME)으로 조회하기
SELECT * FROM EMP_RENAME;

-- 12-14 EMP_RENAME 테이블의 전체 데이터 삭제하기
TRUNCATE TABLE EMP_RENAME;
SELECT * FROM EMP_RENAME;

-- 12-15 EMP_RENAME 테이블 삭제하기
DROP TABLE EMP_RENAME;

-- 12-16 EMP_RENAME 테이블 구성 살펴보기
DESC EMP_RENAME;

-- 324P Q1


-- 13-1 SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기(DICT 사용)
SELECT * FROM DICT;

-- 13-2 SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기(DICTIONARY 사용)
SELECT * FROM DICTIONARY;

-- 13-3 SCOTT 계정이 가지고 있는 객체 정보 살펴보기(USER_접두어 사용)
SELECT TABLE_NAME FROM USER_TABLES;

-- 13-4 SCOTT 계정이 사용할 수 있는 객체 정보 살펴보기(ALL_접두어 사용)
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

-- 13-5 SCOTT 계정으로 DBA_접두어 사용하기
SELECT * FROM DBA_TABLES;



---------------- 15. 사용자, 권한, 롤 관리 ------------------------

-- 15-1 SCOTT 계정으로 사용자 생성하기
CREATE USER ORCLSTUDY IDENTIFIED BY ORACLE;














